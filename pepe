import requests
import os
from datetime import datetime, timedelta

def download_monthly_data(symbol, start_date, end_date, output_dir):
    current_date = start_date
    while current_date <= end_date:
        year = current_date.strftime("%Y")
        month = current_date.strftime("%m")
        url = f"https://data.binance.vision/data/spot/monthly/klines/{symbol}/1m/{symbol}-1m-{year}-{month}.zip"
        output_file = f"{symbol}-1m-{year}-{month}.zip"
        
        # 创建输出目录(如果不存在)
        os.makedirs(output_dir, exist_ok=True)
        
        # 发送GET请求并下载文件
        response = requests.get(url)
        with open(os.path.join(output_dir, output_file), "wb") as file:
            file.write(response.content)
        
        print(f"文件 {output_file} 下载完成!")
        
        # 更新当前日期为下个月的第一天
        current_date = current_date + timedelta(days=32)
        current_date = datetime(current_date.year, current_date.month, 1)

# 设置参数
symbol = "PEPEUSDT"
start_date = datetime(2023, 1, 1)
end_date = datetime(2024, 4, 30)
output_dir = "D:/1m"

# 调用函数下载数据
download_monthly_data(symbol, start_date, end_date, output_dir)

import os
import zipfile

def extract_files(directory):
    for filename in os.listdir(directory):
        if filename.endswith(".zip"):
            try:
                file_path = os.path.join(directory, filename)
                with zipfile.ZipFile(file_path, "r") as zip_ref:
                    zip_ref.extractall(directory)
                print(f"文件 {filename} 解压完成!")
            except:pass
# 设置数据文件所在的目录
data_directory = "D:/1m"

# 调用函数解压文件
extract_files(data_directory)


import requests
import json
import time
from datetime import datetime, timedelta

# Binance API的基础URL
base_url = 'https://api.binance.com'

# 指定交易对,如PEPEUSDT
symbol = 'PEPEUSDT'

# 指定时间间隔,1m表示5分钟
interval = '1m'

# 指定开始时间为2024年4月1日0点
start_time = datetime(2024, 4, 1, 8, 0, 0)

# 获取当前时间
now = datetime.now()

# 计算时间差并将其转换为秒数
time_diff = now - start_time
time_diff_seconds = time_diff.total_seconds()

# 计算5分钟的时间间隔对应的秒数
interval_seconds = 60*24 * 60

# 计算需要获取的数据条数
total_limit = int(time_diff_seconds // interval_seconds) + 1

# 每次请求获取的数据条数
batch_size = 1000

# 初始化开始时间戳
start_timestamp = int(start_time.timestamp() * 1000)
alldatas=[]

fs=glob.glob('D:/1m/PEPEUSDT-1m-*csv')#[:-1]

df=pd.concat([pd.read_csv(f,header=None) for f in fs])
df=pd.DataFrame(df.values,columns=['Open time','Open','High','Low','Close','Volume','Close time','Quote asset volume','Number of trades','Taker buy base asset volume','Taker buy quote asset volume','Ignore'])

df=df.drop_duplicates()

df.index=range(len(df))

df['buy_ratio1']=df['Taker buy base asset volume']/df['Volume']

df['buy_ratio2']=df['Taker buy quote asset volume']/df['Quote asset volume']

df.to_parquet('D:/1m/1mPEPEUSDT240420.parquet')
















#################PEPEUSDT 1m
import requests
import json
import time
from datetime import datetime, timedelta
import os

os.environ['https_proxy'] = 'http://127.0.0.1:7890/'
os.environ['http_proxy'] = 'http://127.0.0.1:7890/'

# Binance API的基础URL
base_url = 'https://api.binance.com'

# 指定交易对,如PEPEUSDT
symbol = 'PEPEUSDT'

# 指定时间间隔,5m表示5分钟
interval = '1m'
now = datetime.now()
from datetime import datetime, timedelta

now = datetime.now()

# 获取当前日期的前一天
previous_day = now.date() - timedelta(days=1)

# 将前一天的日期设置为0点0分0秒
#start_time = datetime(previous_day.year, previous_day.month, previous_day.day, 6, 0, 0)
now=now.replace(minute=int(now.minute//1)*1,second=0,microsecond=0)
start_time=now - timedelta(minutes=1*200)
# 计算时间差并将其转换为秒数
time_diff = now - start_time
time_diff_seconds = time_diff.total_seconds()

# 计算5分钟的时间间隔对应的秒数
interval_seconds = 1 * 60

# 计算需要获取的数据条数
total_limit = int(time_diff_seconds // interval_seconds) + 1

# 每次请求获取的数据条数
batch_size = 1000

# 初始化开始时间戳
start_timestamp = int(start_time.timestamp() * 1000)
alldatas=[]
while total_limit > 0:
    #try:
        # 计算每次请求的数据条数
        limit = min(batch_size, total_limit)

        # 构建请求的URL
        url = f'{base_url}/api/v3/klines?symbol={symbol}&interval={interval}&startTime={start_timestamp}&limit={limit}'

        # 发送GET请求
        response = requests.get(url)

        # 解析响应的JSON数据
        data = json.loads(response.text)
        if len(data) > 0:
            # 更新开始时间戳和剩余数据条数
            start_timestamp = data[-1][0] + interval_seconds * 1000
            total_limit -= limit
        alldatas+=data

        # 添加请求间隔时间,避免超过API限制
        #time.sleep(1)
import datetime
rollbardf=pd.DataFrame(np.array(alldatas).astype(np.float64),columns=['Open time','Open','High','Low','Close','Volume','Close time','Quote asset volume','Number of trades','Taker buy base asset volume','Taker buy quote asset volume','Ignore']).drop_duplicates()
rollbardf.index=range(len(rollbardf))

import datetime
rollbardf['time']=rollbardf['Open time'].apply(lambda x:datetime.datetime.fromtimestamp(x/1000)).apply(lambda x: str(x)+'+08:00')
#rollbardf=rollbardf.drop(['Open time'],axis=1)
rollbardf.set_index('time',inplace=True)
rollbardf.to_csv('autodl-tmp/PEPErollbardf')

def main():
    import requests
    import json
    import time
    from datetime import datetime, timedelta
    import os

    os.environ['https_proxy'] = 'http://127.0.0.1:7890/'
    os.environ['http_proxy'] = 'http://127.0.0.1:7890/'

    # Binance API的基础URL
    base_url = 'https://api.binance.com'

    # 指定交易对,如PEPEUSDT
    symbol = 'PEPEUSDT'

    # 指定时间间隔,5m表示5分钟
    interval = '1m'
    now = datetime.now()
    from datetime import datetime, timedelta

    now = datetime.now()

    # 将前一天的日期设置为0点0分0秒
    start_time = now-timedelta(minutes=30)
    start_time=start_time.replace(minute=int(start_time.minute//1)*1,second=0,microsecond=0)
    now=now.replace(minute=int(now.minute//1)*1,second=0,microsecond=0)
    # 计算时间差并将其转换为秒数
    time_diff = now - start_time
    time_diff_seconds = time_diff.total_seconds()

    # 计算5分钟的时间间隔对应的秒数
    interval_seconds = 1 * 60

    # 计算需要获取的数据条数
    total_limit = int(time_diff_seconds // interval_seconds) + 1

    # 每次请求获取的数据条数
    batch_size = 1000

    # 初始化开始时间戳
    start_timestamp = int(start_time.timestamp() * 1000)
    alldatas=[]
    while total_limit > 0:
        #try:
            # 计算每次请求的数据条数
            limit = min(batch_size, total_limit)

            # 构建请求的URL
            url = f'{base_url}/api/v3/klines?symbol={symbol}&interval={interval}&startTime={start_timestamp}&limit={limit}'

            # 发送GET请求
            response = requests.get(url)

            # 解析响应的JSON数据
            data = json.loads(response.text)
            if len(data) > 0:
                # 更新开始时间戳和剩余数据条数
                start_timestamp = data[-1][0] + interval_seconds * 1000
                total_limit -= limit
            alldatas+=data

            # 添加请求间隔时间,避免超过API限制
            #time.sleep(1)
    import datetime
    rollbardf=pd.DataFrame(np.array(alldatas).astype(np.float64),columns=['Open time','Open','High','Low','Close','Volume','Close time','Quote asset volume','Number of trades','Taker buy base asset volume','Taker buy quote asset volume','Ignore']).drop_duplicates()
    rollbardf.index=range(len(rollbardf))

    import datetime
    rollbardf['time']=rollbardf['Open time'].apply(lambda x:datetime.datetime.fromtimestamp(x/1000)).apply(lambda x: str(x)+'+08:00')
    #rollbardf=rollbardf.drop(['Open time'],axis=1)
    rollbardf.set_index('time',inplace=True)

    tmp=pd.concat([pd.read_csv('autodl-tmp/PEPErollbardf').set_index('time'),rollbardf],axis=0).drop_duplicates()#.drop_duplicates(keep='last')

    tmp['time']=tmp.index

    tmp.drop_duplicates(subset='time', keep='last').drop(['time'],axis=1).iloc[-210:].to_csv('autodl-tmp/PEPErollbardf')

from apscheduler.schedulers.blocking import BlockingScheduler
scheduler = BlockingScheduler()
scheduler.add_job(main, 'cron',  minute='0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59') #实时下单
scheduler.start()


























import os

os.environ['https_proxy'] = 'http://127.0.0.1:7890/'
os.environ['http_proxy'] = 'http://127.0.0.1:7890/'

def mainrun():
    import os

    os.environ['https_proxy'] = 'http://127.0.0.1:7890/'
    os.environ['http_proxy'] = 'http://127.0.0.1:7890/'

    from ft import FT

    from datetime import datetime, timedelta
    import requests
    import json
    import time
    from datetime import datetime, timedelta
    import datetime
    rollbardf=pd.read_csv('autodl-tmp/PEPErollbardf').set_index('time')
    import binance
    import time
    import os
    import time
    import datetime
    from binance.client import Client
    API_KEY = 'dtZ8mQh0LWuytNqzfvDMN6sbJRTxpUbNJ9WKkT8YFRltLkir1ezmD1vCVv8Hz56p'
    API_SECRET = 'jufQS4dkzXTG3xjq7D9RbJzEc9h9jOdwBxY4RhwixWsl7wTWYIZI8DUd1DJKBPDl'
    # 创建Binance客户端实例
    client = Client(API_KEY, API_SECRET)
    client.SPOT_USE_BNB_FOR_FEES = True
    client.FUTURES_USE_BNB_FOR_FEES = True

    # 指定交易对
    symbol = "PEPEUSDT"

    # 获取今日0点的Unix毫秒时间戳
    today_0000 = int(datetime.datetime.combine(datetime.date.today(), datetime.time(0, 0, 0)).timestamp() * 1000)


    #while True:
    for _ in range(1):
        # 获取当前时间
        from datetime import datetime
        now = datetime.now()

        # 计算上一个1分钟的起始时间和结束时间
        end_time = now.replace(minute=now.minute // 1 * 1, second=0, microsecond=0)
        start_time = end_time - timedelta(minutes=1)
        from datetime import datetime, timedelta

        # Binance API的基础URL
        base_url = 'https://api.binance.com'

        # 指定交易对,如PEPEUSDT
        symbol = 'PEPEUSDT'

        # 指定时间间隔,5m表示5分钟
        interval = '1m'
        now = datetime.now()

        # 计算时间差并将其转换为秒数
        time_diff = now - start_time
        time_diff_seconds = time_diff.total_seconds()

        # 计算5分钟的时间间隔对应的秒数
        interval_seconds = 1 * 60

        # 计算需要获取的数据条数
        total_limit = int(time_diff_seconds // interval_seconds) + 1

        # 每次请求获取的数据条数
        batch_size = 1000

        # 初始化开始时间戳
        start_timestamp = int(start_time.timestamp() * 1000)
        alldatas=[]
        while total_limit > 0:
            #try:
                # 计算每次请求的数据条数
                limit = min(batch_size, total_limit)

                # 构建请求的URL
                url = f'{base_url}/api/v3/klines?symbol={symbol}&interval={interval}&startTime={start_timestamp}&limit={limit}'

                # 发送GET请求
                response = requests.get(url)

                # 解析响应的JSON数据
                data = json.loads(response.text)
                if len(data) > 0:
                    # 更新开始时间戳和剩余数据条数
                    start_timestamp = data[-1][0] + interval_seconds * 1000
                    total_limit -= limit
                alldatas+=data

                # 添加请求间隔时间,避免超过API限制
                #time.sleep(1)
        import datetime
        latestbardf=pd.DataFrame(np.array(alldatas).astype(np.float64),columns=['Open time','Open','High','Low','Close','Volume','Close time','Quote asset volume','Number of trades','Taker buy base asset volume','Taker buy quote asset volume','Ignore']).drop_duplicates()
        latestbardf.index=range(len(latestbardf))

        import datetime
        latestbardf['time']=latestbardf['Open time'].apply(lambda x:datetime.datetime.fromtimestamp(x/1000)).apply(lambda x: str(x)+'+08:00')
        #latestbardf=latestbardf.drop(['Open time'],axis=1)
        latestbardf.set_index('time',inplace=True)

        tmp=pd.concat([rollbardf,latestbardf],axis=0).drop_duplicates()
        tmp['time']=tmp.index
        rollbardf=tmp.drop_duplicates(subset='time', keep='last')
        rollbardf=rollbardf.set_index('time')
        from ft import FT
        alpha = FT(rollbardf)
        features0 = alpha.calculate()

        features0['buy_ratio1']=rollbardf['Taker buy base asset volume']/rollbardf['Volume']
        features0['buy_ratio2']=rollbardf['Taker buy quote asset volume']/rollbardf['Quote asset volume']

        features=pd.concat([rollbardf,features0],axis=1)
        features=features.loc[rollbardf.index]
        try:features=features.drop(['target'],axis=1)
        except:pass
        try:features=features.drop(['T'],axis=1)
        except:pass
        try:features=features.drop(['time'],axis=1)
        except:pass  
        import joblib
        model=joblib.load(f'PEPElatest')
        cols=['Open_roc_5', 'Open_ma_5', 'Open_std_5', 'Open_beta_5', 'Open_q20_5', 'Open_q80_5', 'Open_min_5', 'Open_max_5', 'Open_roc_10', 'Open_ma_10', 'Open_std_10', 'Open_beta_10', 'Open_q20_10', 'Open_q80_10', 'Open_min_10', 'Open_max_10', 'Open_roc_20', 'Open_ma_20', 'Open_std_20', 'Open_beta_20', 'Open_q20_20', 'Open_q80_20', 'Open_min_20', 'Open_max_20', 'Open_roc_30', 'Open_ma_30', 'Open_std_30', 'Open_beta_30', 'Open_q20_30', 'Open_q80_30', 'Open_min_30', 'Open_max_30', 'Open_roc_60', 'Open_ma_60', 'Open_std_60', 'Open_beta_60', 'Open_q20_60', 'Open_q80_60', 'Open_min_60', 'Open_max_60', 'High_roc_5', 'High_ma_5', 'High_std_5', 'High_beta_5', 'High_q20_5', 'High_q80_5', 'High_min_5', 'High_max_5', 'High_roc_10', 'High_ma_10', 'High_std_10', 'High_beta_10', 'High_q20_10', 'High_q80_10', 'High_min_10', 'High_max_10', 'High_roc_20', 'High_ma_20', 'High_std_20', 'High_beta_20', 'High_q20_20', 'High_q80_20', 'High_min_20', 'High_max_20', 'High_roc_30', 'High_ma_30', 'High_std_30', 'High_beta_30', 'High_q20_30', 'High_q80_30', 'High_min_30', 'High_max_30', 'High_roc_60', 'High_ma_60', 'High_std_60', 'High_beta_60', 'High_q20_60', 'High_q80_60', 'High_min_60', 'High_max_60', 'Low_roc_5', 'Low_ma_5', 'Low_std_5', 'Low_beta_5', 'Low_q20_5', 'Low_q80_5', 'Low_min_5', 'Low_max_5', 'Low_roc_10', 'Low_ma_10', 'Low_std_10', 'Low_beta_10', 'Low_q20_10', 'Low_q80_10', 'Low_min_10', 'Low_max_10', 'Low_roc_20', 'Low_ma_20', 'Low_std_20', 'Low_beta_20', 'Low_q20_20', 'Low_q80_20', 'Low_min_20', 'Low_max_20', 'Low_roc_30', 'Low_ma_30', 'Low_std_30', 'Low_beta_30', 'Low_q20_30', 'Low_q80_30', 'Low_min_30', 'Low_max_30', 'Low_roc_60', 'Low_ma_60', 'Low_std_60', 'Low_beta_60', 'Low_q20_60', 'Low_q80_60', 'Low_min_60', 'Low_max_60', 'Close_roc_5', 'Close_ma_5', 'Close_std_5', 'Close_beta_5', 'Close_q20_5', 'Close_q80_5', 'Close_min_5', 'Close_max_5', 'Close_roc_10', 'Close_ma_10', 'Close_std_10', 'Close_beta_10', 'Close_q20_10', 'Close_q80_10', 'Close_min_10', 'Close_max_10', 'Close_roc_20', 'Close_ma_20', 'Close_std_20', 'Close_beta_20', 'Close_q20_20', 'Close_q80_20', 'Close_min_20', 'Close_max_20', 'Close_roc_30', 'Close_ma_30', 'Close_std_30', 'Close_beta_30', 'Close_q20_30', 'Close_q80_30', 'Close_min_30', 'Close_max_30', 'Close_roc_60', 'Close_ma_60', 'Close_std_60', 'Close_beta_60', 'Close_q20_60', 'Close_q80_60', 'Close_min_60', 'Close_max_60', 'Volume_roc_5', 'Volume_ma_5', 'Volume_std_5', 'Volume_roc_10', 'Volume_ma_10', 'Volume_std_10', 'Volume_roc_20', 'Volume_ma_20', 'Volume_std_20', 'Volume_roc_30', 'Volume_ma_30', 'Volume_std_30', 'Volume_roc_60', 'Volume_ma_60', 'Volume_std_60', 'price_volume_roc_5', 'price_volume_ma_5', 'amount_ma_5', 'wvma_5', 'v_sump_5', 'v_sumn_5', 'psy_line_5', 'price_volume_roc_10', 'price_volume_ma_10', 'amount_ma_10', 'wvma_10', 'v_sump_10', 'v_sumn_10', 'psy_line_10', 'price_volume_roc_20', 'price_volume_ma_20', 'amount_ma_20', 'wvma_20', 'v_sump_20', 'v_sumn_20', 'psy_line_20', 'price_volume_roc_30', 'price_volume_ma_30', 'amount_ma_30', 'wvma_30', 'v_sump_30', 'v_sumn_30', 'psy_line_30', 'price_volume_roc_60', 'price_volume_ma_60', 'amount_ma_60', 'wvma_60', 'v_sump_60', 'v_sumn_60', 'psy_line_60', 'return_ma_5', 'fractal_dimension_hausdorff_5', 'fractal_dimension_hurst_5', 'smart_money_flow_5', 'momentum_reversal_5', 'jump_risk_005_5', 'jump_risk_01_5', 'pos_neg_volume_5', 'avg_candle_body_5', 'avg_candle_shadow_5', 'information_ratio_5', 'volume_burst_5', 'price_breakout_5', 'price_oscillation_5', 'volume_price_divergence_5', 'vwap_5', 'fractal_dimension_hausdorff_10', 'fractal_dimension_hurst_10', 'smart_money_flow_10', 'momentum_reversal_10', 'jump_risk_005_10', 'jump_risk_01_10', 'pos_neg_volume_10', 'avg_candle_body_10', 'avg_candle_shadow_10', 'information_ratio_10', 'volume_burst_10', 'price_breakout_10', 'price_oscillation_10', 'volume_price_divergence_10', 'vwap_10', 'fractal_dimension_hausdorff_20', 'fractal_dimension_hurst_20', 'smart_money_flow_20', 'momentum_reversal_20', 'jump_risk_005_20', 'jump_risk_01_20', 'pos_neg_volume_20', 'avg_candle_body_20', 'avg_candle_shadow_20', 'information_ratio_20', 'volume_burst_20', 'price_breakout_20', 'price_oscillation_20', 'volume_price_divergence_20', 'vwap_20', 'fractal_dimension_hausdorff_30', 'fractal_dimension_hurst_30', 'smart_money_flow_30', 'momentum_reversal_30', 'jump_risk_005_30', 'jump_risk_01_30', 'pos_neg_volume_30', 'avg_candle_body_30', 'avg_candle_shadow_30', 'information_ratio_30', 'volume_burst_30', 'price_breakout_30', 'price_oscillation_30', 'volume_price_divergence_30', 'vwap_30', 'fractal_dimension_hausdorff_60', 'fractal_dimension_hurst_60', 'smart_money_flow_60', 'momentum_reversal_60', 'jump_risk_005_60', 'jump_risk_01_60', 'pos_neg_volume_60', 'avg_candle_body_60', 'avg_candle_shadow_60', 'information_ratio_60', 'volume_burst_60', 'price_breakout_60', 'price_oscillation_60', 'volume_price_divergence_60', 'vwap_60', 'rs_ratio_5_10', 'sma_crossover_5_10', 'rs_ratio_10_20', 'sma_crossover_10_20', 'rs_ratio_20_60', 'sma_crossover_20_60', 'return_skewness_5', 'return_kurtosis_5', 'return_skewness_10', 'return_kurtosis_10', 'return_skewness_20', 'return_kurtosis_20', 'return_skewness_30', 'return_kurtosis_30', 'return_skewness_60', 'return_kurtosis_60', 'bullish_candle_ratio_5', 'bullish_candle_ratio_10', 'bullish_candle_ratio_20', 'bullish_candle_ratio_30', 'bullish_candle_ratio_60', 'turnover_rate_5', 'turnover_rate_10', 'turnover_rate_20', 'turnover_rate_30', 'turnover_rate_60', 'abnormal_trading_pattern_2_5', 'abnormal_trading_pattern_3_5', 'abnormal_trading_pattern_2_10', 'abnormal_trading_pattern_3_10', 'abnormal_trading_pattern_2_20', 'abnormal_trading_pattern_3_20', 'abnormal_trading_pattern_2_30', 'abnormal_trading_pattern_3_30', 'abnormal_trading_pattern_2_60', 'abnormal_trading_pattern_3_60', 'price_volume_corr_5', 'price_volume_corr_10', 'price_volume_corr_20', 'price_volume_corr_30', 'price_volume_corr_60', 'price_volume_cointegration_5', 'price_volume_cointegration_10', 'price_volume_cointegration_20', 'price_volume_cointegration_30', 'price_volume_cointegration_60', 'abnormal_volume_5', 'abnormal_volume_10', 'abnormal_volume_20', 'abnormal_volume_30', 'abnormal_volume_60', 'volume_high_low_5', 'volume_high_low_10', 'volume_high_low_20', 'volume_high_low_30', 'volume_high_low_60', 'price_high_low_5', 'price_high_low_10', 'price_high_low_20', 'price_high_low_30', 'price_high_low_60', 'price_cog_5', 'price_cog_10', 'price_cog_20', 'price_cog_30', 'price_cog_60', 'p_v_corr0_5', 'p_v_corr0_10', 'p_v_corr0_20', 'p_v_corr0_30', 'p_v_corr0_60', 'p_v_corr1_5', 'p_v_corr1_10', 'p_v_corr1_20', 'p_v_corr1_30', 'p_v_corr1_60', 'p_v_cord_5', 'p_v_cord_10', 'p_v_cord_20', 'p_v_cord_30', 'p_v_cord_60', 'money_flow_5', 'money_flow_10', 'money_flow_20', 'money_flow_30', 'money_flow_60', 'order_imbalance_5', 'order_imbalance_10', 'order_imbalance_20', 'order_imbalance_30', 'order_imbalance_60', 'price_volatility_5', 'volume_volatility_5', 'price_volatility_10', 'volume_volatility_10', 'price_volatility_20', 'volume_volatility_20', 'price_volatility_30', 'volume_volatility_30', 'price_volatility_60', 'volume_volatility_60', 'Open time', 'Open', 'High', 'Low', 'Close', 'Volume', 'Close time', 'Quote asset volume', 'Number of trades', 'Taker buy base asset volume', 'Taker buy quote asset volume', 'Ignore', 'buy_ratio1', 'buy_ratio2']
        pred=model.predict(features[cols].loc[str(start_time)+'+08:00'].values.reshape([1,-1]))
        pred=np.array([pred]).flatten()[0]
        print(pred,start_time)

        symbol = f'1000PEPEUSDC'

        account_balance = float(client.futures_account_balance(asset='USDC')[0]['balance'])
        position1 =np.load('1000PEPEUSDCposition1.npy')[0]# float(client.futures_position_information(symbol=symbol)[0]['positionAmt'])  # 买仓数量
        position2 =np.load('1000PEPEUSDCposition2.npy')[0]# -float(client.futures_position_information(symbol=symbol)[1]['positionAmt']) if len(client.futures_position_information(symbol=symbol)) > 1 else 0  # 卖仓数量
        current_price = float(client.futures_symbol_ticker(symbol=symbol)['price'])

        fee = 0.017*0.9 / 100
        slippage = 0.02 / 100

        # 设置杠杆为40倍
        leverage = 1
        client.futures_change_leverage(symbol=symbol, leverage=leverage)

        key1, key2 = 0.00028333333333333335,-0.00028333333333333335

        if pred < key1 and position1 > 0:
            # 卖出永续合约平仓
            order = client.futures_create_order(
                symbol=symbol,
                side=Client.SIDE_SELL,
                type=Client.ORDER_TYPE_MARKET,
                quantity=position1,
                reduceOnly=True,
                recvWindow=5000
            )
            account_balance += position1 * current_price * (1 - slippage) * (1 - fee) / leverage
            position1 = 0

        if pred > key2 and position2 > 0:
            # 买入永续合约平仓
            order = client.futures_create_order(
                symbol=symbol,
                side=Client.SIDE_BUY,
                type=Client.ORDER_TYPE_MARKET,
                quantity=position2,
                reduceOnly=True,
                recvWindow=5000
            )
            account_balance -= position2 * current_price * (1 + slippage) * (1 + fee) / leverage
            position2 = 0

        if pred > key1 and position1 == 0 and position2 == 0:
            # 计算10USDC保证金可买入的合约数量
            buy_quantity = 100 / (current_price * (1 + slippage) * (1 + fee) / leverage)
            buy_contracts = math.floor(buy_quantity * 10**0) / 10**0

            # 买入永续合约
            order = client.futures_create_order(
                symbol=symbol,
                side=Client.SIDE_BUY,
                type=Client.ORDER_TYPE_MARKET,
                quantity=buy_contracts,
                recvWindow=5000
            )
            position1 = buy_contracts
            account_balance -= buy_contracts * current_price * (1 + slippage) * (1 + fee) / leverage

        if pred < key2 and position1 == 0 and position2 == 0:
            # 计算10USDC保证金可卖出的合约数量
            sell_quantity = 100 / (current_price * (1 - slippage) * (1 - fee) / leverage)
            sell_contracts = math.floor(sell_quantity * 10**0) / 10**0

            # 卖出永续合约开空仓
            order = client.futures_create_order(
                symbol=symbol,
                side=Client.SIDE_SELL,
                type=Client.ORDER_TYPE_MARKET,
                quantity=sell_contracts,
                recvWindow=5000
            )
            position2 = sell_contracts
            account_balance += sell_contracts * current_price * (1 - slippage) * (1 - fee) / leverage
        np.save('1000PEPEUSDCposition1.npy',[position1])
        np.save('1000PEPEUSDCposition2.npy',[position2])
        np.save(f'autodl-tmp/1000PEPEUSDC{start_time}',pred)
from apscheduler.schedulers.blocking import BlockingScheduler
scheduler = BlockingScheduler()
scheduler.add_job(mainrun, 'cron',minute='0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59') #实时下单
scheduler.start()
